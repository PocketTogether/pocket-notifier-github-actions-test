下面是 **按 5 号口令执行** 后生成的全部内容。  
这是一个 **完整、可复用、Android 8+ 兼容的通知系统**，与你的工程风格一致：**机制化、集中化、可 fork、可维护**。

文件路径基于：

```
app/src/main/java/com/pocket/notifier/
```

---

# 📄 `NotificationHelper.kt`

路径：

```
app/src/main/java/com/pocket/notifier/notification/NotificationHelper.kt
```

```kotlin
package com.pocket.notifier.notification

/**
 * NotificationHelper — 通知系统
 *
 * 功能：
 * - 创建通知渠道（Android 8+ 必须）
 * - ForegroundService 专用渠道
 * - 轮询通知专用渠道
 * - 每次轮询后发送成功/失败通知（带时间戳）
 */

import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.os.Build
import androidx.core.app.NotificationCompat
import com.pocket.notifier.R
import java.text.SimpleDateFormat
import java.util.*

object NotificationHelper {

    /** ForegroundService 常驻通知渠道 */
    const val CHANNEL_FOREGROUND = "notifier_foreground"

    /** 轮询通知渠道 */
    const val CHANNEL_POLLING = "notifier_polling"

    /** 初始化通知渠道（在 Application 或 Service 中调用一次） */
    fun initChannels(context: Context) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val manager = context.getSystemService(NotificationManager::class.java)

            val foreground = NotificationChannel(
                CHANNEL_FOREGROUND,
                "后台运行通知",
                NotificationManager.IMPORTANCE_LOW
            ).apply {
                description = "用于保持 Notifier 在后台运行的前台服务通知"
            }

            val polling = NotificationChannel(
                CHANNEL_POLLING,
                "轮询结果通知",
                NotificationManager.IMPORTANCE_DEFAULT
            ).apply {
                description = "每次轮询成功或失败时发送通知"
            }

            manager.createNotificationChannel(foreground)
            manager.createNotificationChannel(polling)
        }
    }

    /** 发送轮询通知 */
    fun sendPollingNotification(context: Context, success: Boolean) {
        val manager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        val statusText = if (success) "请求成功" else "请求失败"

        val timestamp = SimpleDateFormat("HH:mm:ss", Locale.getDefault())
            .format(Date())

        val content = "$statusText · $timestamp"

        val notification = NotificationCompat.Builder(context, CHANNEL_POLLING)
            .setSmallIcon(R.drawable.ic_launcher_foreground)
            .setContentTitle("Notifier 轮询结果")
            .setContentText(content)
            .setAutoCancel(true)
            .build()

        // 使用随机 ID，避免覆盖旧通知
        manager.notify(System.currentTimeMillis().toInt(), notification)
    }
}
```

---

# 📄 `notification_small.xml`（可选）

路径：

```
app/src/main/res/layout/notification_small.xml
```

> 你可以选择使用，也可以不使用。  
> 这是一个简单的自定义通知布局（可扩展）。

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:padding="12dp"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <TextView
        android:id="@+id/title"
        android:text="Notifier 轮询结果"
        android:textSize="16sp"
        android:textStyle="bold"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />

    <TextView
        android:id="@+id/content"
        android:text="成功/失败 + 时间戳"
        android:textSize="14sp"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />

</LinearLayout>
```

> 当前 NotificationHelper 使用系统默认布局。  
> 如果你想启用自定义布局，我可以在后续口令中帮你改写。

---

# 📄 AndroidManifest.xml（追加权限）

在：

```
app/src/main/AndroidManifest.xml
```

的 `<manifest>` 内加入：

```xml
<!-- Android 13+ 通知权限 -->
<uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
```

> Android 13（API 33）开始，通知需要动态权限。  
> 你可以在 MainActivity 中请求权限（如需要，我可以在后续口令中生成）。

---

# ✅ 说明

### ✔ ForegroundService 与轮询通知分离

- `CHANNEL_FOREGROUND` → 用于常驻通知
- `CHANNEL_POLLING` → 用于轮询结果通知

### ✔ 每次轮询后发送通知

包含：

- 成功 / 失败状态
- 时间戳（HH:mm:ss）

### ✔ Android 8+ 兼容

自动创建 NotificationChannel。

### ✔ 可扩展

你可以轻松添加：

- 自定义图标
- 自定义布局
- 点击跳转行为

---

如果你准备继续下一步，可以直接说：

> 按 6 号口令执行

我将为你生成 **SharedPreferences 状态存储（StatusStore.kt）**。