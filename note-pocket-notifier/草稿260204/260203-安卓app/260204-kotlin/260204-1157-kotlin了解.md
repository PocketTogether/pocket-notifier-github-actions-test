```
我想开始研究kotlin开发安卓app
我想做一个很简单的安卓app，用于轮询http/https请求，要保证轮询稳定性
只有一个页面，居中显示一个图片，如果上次请求是失败的则显示另一个图片
每次轮询后，会让手机有通知
这种安卓app的apk，大小大概是多少



完整的kotlin安卓app项目
完整的 OkHttp 轮询服务（ForegroundService）
完整的通知系统
完整的 GitHub Actions 自动打包脚本
完整的 Gradle 配置（尽量小的APK）
完整的项目目录结构

轮询间隔和请求路径，要写在配置文件类似前端项目的config.ts中以方便管理
轮询间隔60秒
请求超时时间10秒
请求路径 https://sakiko.top/api/collections/messages/records?page=1&perPage=40&expand=author&sort=-created%2Cid&skipTotal=true
```

下面我直接给你一套**可用的完整项目骨架**，你可以几乎原样丢进 GitHub，用 GitHub Actions 打包 APK。

---

### 项目目录结构

```text
android-http-poller/
├─ settings.gradle
├─ build.gradle
├─ app/
│  ├─ build.gradle
│  └─ src/
│     └─ main/
│        ├─ AndroidManifest.xml
│        ├─ java/com/example/http_poller/
│        │  ├─ Config.kt
│        │  ├─ MainActivity.kt
│        │  ├─ PollingForegroundService.kt
│        │  └─ NotificationHelper.kt
│        └─ res/
│           ├─ layout/activity_main.xml
│           ├─ drawable/ok.png        ← 你自己放图片
│           └─ drawable/fail.png      ← 你自己放图片
└─ .github/
   └─ workflows/
      └─ android.yml
```

包名这里用 `com.example.http_poller`，你可以改成自己的。

---

### `settings.gradle`

```gradle
rootProject.name = "android-http-poller"
include(":app")
```

---

### 顶层 `build.gradle`

```gradle
buildscript {
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath("com.android.tools.build:gradle:8.5.2")
        classpath("org.jetbrains.kotlin:kotlin-gradle-plugin:1.9.25")
    }
}

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}
```

---

### `app/build.gradle`

尽量小的 APK：开启 R8、关闭调试、只用必要依赖。

```gradle
apply plugin: "com.android.application"
apply plugin: "kotlin-android"

android {
    namespace "com.example.http_poller"
    compileSdkVersion 34

    defaultConfig {
        applicationId "com.example.http_poller"
        minSdkVersion 24
        targetSdkVersion 34
        versionCode 1
        versionName "1.0"

        // ForegroundService 需要
        foregroundServiceType "dataSync"
    }

    buildTypes {
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles(
                    getDefaultProguardFile("proguard-android-optimize.txt"),
                    "proguard-rules.pro"
            )
        }
        debug {
            minifyEnabled false
            shrinkResources false
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }
}

dependencies {
    implementation("org.jetbrains.kotlin:kotlin-stdlib:1.9.25")

    implementation("androidx.core:core-ktx:1.13.1")
    implementation("androidx.appcompat:appcompat:1.7.0")
    implementation("com.google.android.material:material:1.12.0")

    implementation("com.squareup.okhttp3:okhttp:4.12.0")

    implementation("androidx.work:work-runtime-ktx:2.9.1") // 备用，不强依赖逻辑
}
```

> 你可以新建一个空的 `app/proguard-rules.pro` 文件即可。

---

### `Config.kt`（你的“config.ts”）

```kotlin
package com.example.http_poller

object Config {
    // 轮询间隔（毫秒）
    const val POLL_INTERVAL_MS: Long = 60_000L

    // 请求超时时间（秒）
    const val TIMEOUT_SECONDS: Long = 10L

    // 请求路径
    const val REQUEST_URL: String =
        "https://sakiko.top/api/collections/messages/records?page=1&perPage=40&expand=author&sort=-created%2Cid&skipTotal=true"

    // SharedPreferences key
    const val PREFS_NAME = "poller_prefs"
    const val KEY_LAST_SUCCESS = "last_success"
}
```

---

### `AndroidManifest.xml`

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.http_poller">

    <application
        android:allowBackup="true"
        android:label="HTTP Poller"
        android:icon="@mipmap/ic_launcher"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.MaterialComponents.DayNight.NoActionBar">

        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <service
            android:name=".PollingForegroundService"
            android:exported="false"
            android:foregroundServiceType="dataSync" />
    </application>

</manifest>
```

---

### `NotificationHelper.kt`

```kotlin
package com.example.http_poller

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.os.Build
import androidx.core.app.NotificationCompat

object NotificationHelper {
    private const val CHANNEL_ID = "poller_channel"
    private const val CHANNEL_NAME = "HTTP Poller"

    const val NOTIFICATION_ID_FOREGROUND = 1
    const val NOTIFICATION_ID_RESULT = 2

    fun createChannel(context: Context) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val manager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            val channel = NotificationChannel(
                CHANNEL_ID,
                CHANNEL_NAME,
                NotificationManager.IMPORTANCE_LOW
            )
            manager.createNotificationChannel(channel)
        }
    }

    fun createForegroundNotification(context: Context): Notification {
        return NotificationCompat.Builder(context, CHANNEL_ID)
            .setContentTitle("HTTP 轮询中")
            .setContentText("正在定期请求服务器…")
            .setSmallIcon(android.R.drawable.stat_sys_download_done)
            .setOngoing(true)
            .build()
    }

    fun showResultNotification(context: Context, success: Boolean) {
        val manager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        val text = if (success) "本次轮询成功" else "本次轮询失败"
        val notification = NotificationCompat.Builder(context, CHANNEL_ID)
            .setContentTitle("轮询结果")
            .setContentText(text)
            .setSmallIcon(
                if (success) android.R.drawable.checkbox_on_background
                else android.R.drawable.ic_delete
            )
            .setAutoCancel(true)
            .build()
        manager.notify(NOTIFICATION_ID_RESULT, notification)
    }
}
```

---

### `PollingForegroundService.kt`

```kotlin
package com.example.http_poller

import android.app.Service
import android.content.Context
import android.content.Intent
import android.os.Handler
import android.os.IBinder
import android.os.Looper
import androidx.core.content.edit
import okhttp3.OkHttpClient
import okhttp3.Request
import java.util.concurrent.TimeUnit

class PollingForegroundService : Service() {

    private val handler = Handler(Looper.getMainLooper())
    private val client: OkHttpClient by lazy {
        OkHttpClient.Builder()
            .connectTimeout(Config.TIMEOUT_SECONDS, TimeUnit.SECONDS)
            .readTimeout(Config.TIMEOUT_SECONDS, TimeUnit.SECONDS)
            .writeTimeout(Config.TIMEOUT_SECONDS, TimeUnit.SECONDS)
            .build()
    }

    private val pollRunnable = object : Runnable {
        override fun run() {
            doRequest()
            handler.postDelayed(this, Config.POLL_INTERVAL_MS)
        }
    }

    override fun onCreate() {
        super.onCreate()
        NotificationHelper.createChannel(this)
        val notification = NotificationHelper.createForegroundNotification(this)
        startForeground(NotificationHelper.NOTIFICATION_ID_FOREGROUND, notification)
        handler.post(pollRunnable)
    }

    override fun onDestroy() {
        handler.removeCallbacks(pollRunnable)
        super.onDestroy()
    }

    override fun onBind(intent: Intent?): IBinder? = null

    private fun doRequest() {
        val request = Request.Builder()
            .url(Config.REQUEST_URL)
            .get()
            .build()

        // 简单同步请求，放在后台线程
        Thread {
            var success = false
            try {
                client.newCall(request).execute().use { response ->
                    success = response.isSuccessful
                }
            } catch (e: Exception) {
                success = false
            }

            saveLastResult(success)
            NotificationHelper.showResultNotification(this, success)
        }.start()
    }

    private fun saveLastResult(success: Boolean) {
        val prefs = getSharedPreferences(Config.PREFS_NAME, Context.MODE_PRIVATE)
        prefs.edit {
            putBoolean(Config.KEY_LAST_SUCCESS, success)
        }
    }

    companion object {
        fun start(context: Context) {
            val intent = Intent(context, PollingForegroundService::class.java)
            context.startForegroundService(intent)
        }
    }
}
```

---

### `MainActivity.kt`

```kotlin
package com.example.http_poller

import android.content.Context
import android.os.Bundle
import android.widget.ImageView
import androidx.appcompat.app.AppCompatActivity

class MainActivity : AppCompatActivity() {

    private lateinit var statusImage: ImageView

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        NotificationHelper.createChannel(this)
        setContentView(R.layout.activity_main)

        statusImage = findViewById(R.id.statusImage)

        // 启动前台轮询服务
        PollingForegroundService.start(this)
    }

    override fun onResume() {
        super.onResume()
        updateImageFromLastResult()
    }

    private fun updateImageFromLastResult() {
        val prefs = getSharedPreferences(Config.PREFS_NAME, Context.MODE_PRIVATE)
        val lastSuccess = prefs.getBoolean(Config.KEY_LAST_SUCCESS, true)
        val resId = if (lastSuccess) R.drawable.ok else R.drawable.fail
        statusImage.setImageResource(resId)
    }
}
```

---

### `res/layout/activity_main.xml`

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ImageView
        android:id="@+id/statusImage"
        android:layout_width="120dp"
        android:layout_height="120dp"
        android:layout_gravity="center"
        android:contentDescription="@string/app_name"
        android:src="@drawable/ok" />

</FrameLayout>
```

你需要在 `res/values/strings.xml` 里有一个 `app_name`，Android Studio 不装也可以手写：

```xml
<resources>
    <string name="app_name">HTTP Poller</string>
</resources>
```

---

### GitHub Actions：`.github/workflows/android.yml`

```yaml
name: Android CI

on:
  push:
    branches: [ main, master ]
  pull_request:

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Set up Android SDK
        uses: android-actions/setup-android@v3

      - name: Accept licenses
        run: yes | sdkmanager --licenses

      - name: Build Release APK
        run: ./gradlew assembleRelease

      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: app-release-apk
          path: app/build/outputs/apk/release/app-release.apk
```

你 push 到 GitHub 后，每次构建都会在 Actions 里生成 `app-release.apk`，你直接下载测试即可，全程不需要安装 Android Studio。

---

如果你愿意，下一步我们可以再做一件事：  
把这个项目抽象成“模板仓库”的协议（比如哪些文件是你以后常改的：`Config.kt`、包名、图标），让你以后复制一个新轮询 app 只需要改 2–3 个点。