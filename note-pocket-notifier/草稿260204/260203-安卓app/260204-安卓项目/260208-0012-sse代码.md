```kotlin
app\src\main\java\com\pocket\notifier\service\PollingService.kt

  private val client by lazy {
        OkHttpClient.Builder()
            .connectTimeout(Config.REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS)
            .readTimeout(Config.REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS)
            .writeTimeout(Config.REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS)
            .build()
    }

    private val clientForSSE by lazy {
        OkHttpClient.Builder()
            .connectTimeout(Config.REALTIME_SESSION_SECONDS, TimeUnit.SECONDS)
            .readTimeout(Config.REALTIME_SESSION_SECONDS, TimeUnit.SECONDS)
            .writeTimeout(Config.REALTIME_SESSION_SECONDS, TimeUnit.SECONDS)
            .retryOnConnectionFailure(false)
            .build()
    }

    /** SSE å®æ—¶å®¢æˆ·ç«¯ */
    private lateinit var realtimeClient: RealtimeClient

    override fun onCreate() {
        super.onCreate()

        // åˆå§‹åŒ–é€šçŸ¥æ¸ é“
        NotificationHelper.initChannels(this)

        // å‰å°æœåŠ¡å¸¸é©»é€šçŸ¥
        startForeground(1, createForegroundNotification())

        // å¯åŠ¨è½®è¯¢å¾ªç¯
        startPollingLoop()

        // å¯åŠ¨ SSE å®æ—¶å¾ªç¯
        realtimeClient = RealtimeClient(this, client, clientForSSE, scope)
        realtimeClient.start()
    }


app\src\main\java\com\pocket\notifier\service\RealtimeClient.kt
class RealtimeClient(
    private val context: Context,
    private val client: OkHttpClient, // ç”¨äº POST /api/realtimeï¼ˆè®¢é˜…ï¼‰ 
    private val clientForSSE: OkHttpClient, // ç”¨äº GET /api/realtimeï¼ˆé•¿è¿æ¥ï¼‰
    private val scope: CoroutineScope
) {

    /**
    * å•æ¬¡ SSE ä¼šè¯ï¼š
    * - å»ºç«‹ GET /api/realtime
    * - åœ¨ä¼šè¯æ—¶é—´çª—å£å†…æŒç»­è¯»å– SSE è¡Œ
    * - ä»…åœ¨çœŸæ­£æ–­å¼€ã€EOFã€å¼‚å¸¸ã€æˆ–è¶…è¿‡ä¼šè¯æ—¶é•¿æ—¶ç»“æŸ
    * - â€œ5 ç§’æ— æ•°æ®â€å±äºæ­£å¸¸æƒ…å†µï¼Œä¸åº”ç»“æŸä¼šè¯
    */
    private suspend fun connectOnce() {
        NotificationHelper.sendError(context, "SSE: å¼€å§‹å»ºç«‹è¿æ¥")

        val request = Request.Builder()
            .url(Config.REALTIME_URL)
            .get()
            .build()

        clientForSSE.newCall(request).execute().use { response ->
            if (!response.isSuccessful) {
                NotificationHelper.sendError(context, "SSE: è¿æ¥å¤±è´¥ HTTP ${response.code}")
                throw IOException("HTTP ${response.code} on realtime connect")
            }

            NotificationHelper.sendError(context, "SSE: è¿æ¥æˆåŠŸï¼Œå¼€å§‹è¯»å–äº‹ä»¶")

            val body = response.body ?: throw IOException("Empty realtime body")
            val source = body.source()

            var currentEvent: String? = null
            var dataBuilder = StringBuilder()
            val startTime = System.currentTimeMillis()

            while (
                scope.isActive &&
                System.currentTimeMillis() - startTime <
                Config.REALTIME_SESSION_SECONDS * 1000
            ) {

                /**
                * â­ å…³é”®ç‚¹ï¼š
                * readUtf8Line() æ˜¯é˜»å¡çš„ï¼Œå¦‚æœæœåŠ¡å™¨é•¿æ—¶é—´ä¸å‘æ•°æ®ï¼ˆæ­£å¸¸æƒ…å†µï¼‰ï¼Œ
                * ä¼šä¸€ç›´å¡ä½ï¼Œå¯¼è‡´æ— æ³•æ£€æµ‹ï¼š
                * - ä¼šè¯æ˜¯å¦è¶…è¿‡ 120 ç§’
                * - scope æ˜¯å¦å–æ¶ˆ
                *
                * æ‰€ä»¥æˆ‘ä»¬ç”¨ withTimeoutOrNull(5000) è®©å®ƒâ€œé†’ä¸€ä¸‹â€ã€‚
                *
                * ä½†é†’ä¸€ä¸‹ä¸ä»£è¡¨æ–­å¼€ï¼
                * 5 ç§’æ— æ•°æ®æ˜¯æ­£å¸¸çš„ï¼Œä¸åº”è¯¥ breakã€‚
                */
                val line = withTimeoutOrNull(5_000) {
                    source.readUtf8Line()
                }

                // â­ 5 ç§’æ— æ•°æ® â†’ æ­£å¸¸æƒ…å†µ â†’ ç»§ç»­ç­‰å¾…ä¸‹ä¸€è½®
                if (line == null) {
                    // ä½ å¯ä»¥çœ‹åˆ°æ¯ 5 ç§’ä¸€æ¬¡çš„â€œé™é»˜å¿ƒè·³â€
                    NotificationHelper.sendError(context, "SSE: 5 ç§’æ— æ•°æ®ï¼ˆæ­£å¸¸ï¼‰")
                    continue
                }
                NotificationHelper.sendError(context, "SSE: æ”¶åˆ°pbçš„å¿ƒè·³")

                // â­ ç©ºè¡Œè¡¨ç¤ºä¸€ä¸ª SSE äº‹ä»¶ç»“æŸ
                if (line.isEmpty()) {
                    val data = dataBuilder.toString().trim()
                    if (data.isNotEmpty()) {
                        NotificationHelper.sendError(context, "SSE: æ”¶åˆ°äº‹ä»¶ â†’ $currentEvent")
                        handleEvent(currentEvent, data)
                    }
                    currentEvent = null
                    dataBuilder = StringBuilder()
                    continue
                }

                // â­ è§£æ event: å’Œ data:
                when {
                    line.startsWith("event:") -> {
                        currentEvent = line.removePrefix("event:").trim()
                        NotificationHelper.sendError(context, "SSE: event = $currentEvent")
                    }

                    line.startsWith("data:") -> {
                        if (dataBuilder.isNotEmpty()) dataBuilder.append('\n')
                        dataBuilder.append(line.removePrefix("data:").trim())
                    }
                }
            }

            NotificationHelper.sendError(context, "SSE: ä¼šè¯ç»“æŸï¼ˆæ­£å¸¸æˆ–è¶…æ—¶ï¼‰")
        }
    }
	
	
app\src\main\java\com\pocket\notifier\config\Config.kt
/**
 * ================================
 * ğŸš© å¸¸æ”¹ä½ç½®ï¼ˆé›†ä¸­é…ç½®ï¼‰
 * ================================
 *
 * ä½ å¯ä»¥åœ¨è¿™é‡Œä¿®æ”¹ï¼š
 * - è½®è¯¢é—´éš”ï¼ˆç§’ï¼‰
 * - è¯·æ±‚è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
 * - è¯·æ±‚è·¯å¾„ï¼ˆAPI URLï¼‰
 * - å®æ—¶ SSE ç›¸å…³é…ç½®
 *
 * æ‰€æœ‰é…ç½®å‡ä¸º constï¼Œç¼–è¯‘æœŸå¸¸é‡ï¼Œä¾¿äºç»Ÿä¸€ç®¡ç†ã€‚
 */

package com.pocket.notifier.config

object Config {

    /** è½®è¯¢é—´éš”ï¼ˆç§’ï¼‰ */
    const val POLLING_INTERVAL_SECONDS: Long = 150

    /** è¯·æ±‚è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ */
    const val REQUEST_TIMEOUT_SECONDS: Long = 10

    /** ç‚¹å‡»ä¸»å›¾ç‰‡æ—¶æ‰“å¼€çš„ç½‘å€ */
    const val CLICK_URL: String = "https://uika.top"

    /** è½®è¯¢è¯·æ±‚è·¯å¾„ */
    const val REQUEST_URL: String =
        "https://uika.top/api/collections/messages/records?page=1&perPage=40&expand=author&sort=-created%2Cid&skipTotal=true"

    /** SSE å®æ—¶è¿æ¥åœ°å€ï¼ˆGET /api/realtime & POST /api/realtimeï¼‰ */
    const val REALTIME_URL: String = "https://uika.top/api/realtime"

    /**
     * SSE è®¢é˜…å­—ç¬¦ä¸²
     */
    const val REALTIME_SUBSCRIPTION: String =
        "messages/*?options=%7B%22query%22%3A%7B%22expand%22%3A%22author%22%7D%7D"

    /**
     * å•æ¬¡ SSE ä¼šè¯æ—¶é•¿ï¼ˆç§’ï¼‰
     *
     * æµè§ˆå™¨ç«¯æ˜¯çº¦ 1 åˆ†é’Ÿä¸»åŠ¨æ–­å¼€åé‡è¿ï¼Œè¿™é‡Œä¿æŒä¸€è‡´ã€‚
     */
    const val REALTIME_SESSION_SECONDS: Long = 60
}

```


```
ç°åœ¨çš„é—®é¢˜æ˜¯ withTimeoutOrNull è¿™ä¸ªä¸œè¥¿
å¯¹äº source.readUtf8Line() è¿™ç§å¼ºé˜»å¡æ˜¯æ— æ•ˆçš„ï¼Œå¯¹å—
è¿™å¯¼è‡´æ¯æ¬¡sseåªèƒ½è¢«åŠ¨æ–­å¼€
ä½†æˆ‘æƒ³å®ç°çš„æ˜¯çœŸæ­£ä¸»åŠ¨æ§åˆ¶çš„æ–­å¼€
ä¸ç„¶æˆ‘é…ç½®çš„ REALTIME_SESSION_SECONDS å°±æ¯«æ— æ„ä¹‰äº†
æˆ‘æƒ³å®ç°çš„æ˜¯çœŸæ­£ä¸»åŠ¨æ§åˆ¶çš„æ–­å¼€

æˆ‘è¿™æ ·é€šè¿‡è¶…æ—¶æ¥æ§åˆ¶æ—¶é•¿çš„ï¼Œç¡®è®¤æ­£ç¡®å—
è¿˜è¦å†æ”¹æ”¹å¯¹å§
æ˜¯ä¸æ˜¯è¿˜è¦åœ¨å“ªäº›åœ°æ–¹ä¸“é—¨æ•è·ä¸€ä¸‹ clientForSSE çš„è¶…æ—¶
```


æœ€ç»ˆçš„
```kotlin
    /**
    * å•æ¬¡ SSE ä¼šè¯ï¼š
    * - å»ºç«‹ GET /api/realtime é•¿è¿æ¥
    * - æŒç»­è¯»å– SSE è¡Œç›´åˆ°ï¼š
    *      1) æœåŠ¡å™¨æ–­å¼€ï¼ˆEOFï¼‰
    *      2) å‘ç”Ÿå¼‚å¸¸
    *      3) OkHttp çš„ readTimeout åˆ°æ—¶ï¼ˆæˆ‘ä»¬ç”¨å®ƒæ¥ä¸»åŠ¨æ–­å¼€ï¼‰
    *      4) scope è¢«å–æ¶ˆ
    *
    * â­ å…³é”®æœºåˆ¶è¯´æ˜ï¼š
    * - source.readUtf8Line() æ˜¯â€œå¼ºé˜»å¡ IOâ€ï¼Œä¸ä¼šå“åº”åç¨‹å–æ¶ˆï¼Œä¹Ÿä¸ä¼šè¢« withTimeout ä¸­æ–­
    * - å› æ­¤çœŸæ­£èƒ½ä¸»åŠ¨ä¸­æ–­å®ƒçš„åªæœ‰ OkHttp çš„ readTimeout
    * - å½“ readTimeout åˆ°æ—¶ï¼Œä¼šæŠ›å‡º SocketTimeoutException
    * - æˆ‘ä»¬æŠŠè¿™ä¸ªå¼‚å¸¸è§†ä¸ºâ€œä¸»åŠ¨æ–­å¼€â€ï¼Œè€Œä¸æ˜¯é”™è¯¯
    */
    private suspend fun connectOnce() {
        // NotificationHelper.sendError(context, "SSE: å¼€å§‹å»ºç«‹è¿æ¥")

        val request = Request.Builder()
            .url(Config.REALTIME_URL)
            .get()
            .build()

        // â­ æ–°å¢ï¼šè®°å½•æœ¬æ¬¡ SSE ä¼šè¯çš„å¼€å§‹æ—¶é—´
        val connectStart = System.currentTimeMillis()

        try {
            clientForSSE.newCall(request).execute().use { response ->
                if (!response.isSuccessful) {
                    // NotificationHelper.sendError(context, "SSE: è¿æ¥å¤±è´¥ HTTP ${response.code}")
                    throw IOException("HTTP ${response.code} on realtime connect")
                }

                NotificationHelper.sendError(context, "SSE: è¿æ¥æˆåŠŸï¼Œå¼€å§‹è¯»å–äº‹ä»¶")

                val source = response.body!!.source()

                var currentEvent: String? = null
                var dataBuilder = StringBuilder()

                /**
                * â­ å¾ªç¯æ¡ä»¶ï¼š
                * - scope.isActiveï¼šå…è®¸å¤–éƒ¨ä¸»åŠ¨å–æ¶ˆï¼ˆä¾‹å¦‚æœåŠ¡åœæ­¢ï¼‰
                * - readUtf8Line()ï¼šé˜»å¡ç­‰å¾…æœåŠ¡å™¨å‘é€æ•°æ®
                *
                * âš  æ³¨æ„ï¼š
                * readUtf8Line() æ˜¯å¼ºé˜»å¡ï¼Œä¸ä¼šå› ä¸ºåç¨‹å–æ¶ˆè€Œè‡ªåŠ¨ä¸­æ–­ï¼Œ
                * æ‰€ä»¥çœŸæ­£çš„â€œä¸»åŠ¨æ–­å¼€â€ä¾èµ– OkHttp çš„ readTimeoutã€‚
                */
                while (scope.isActive) {

                    /**
                    * â­ readUtf8Line() è¡Œä¸ºï¼š
                    * - å¦‚æœæœåŠ¡å™¨å‘é€äº†ä¸€è¡Œ â†’ è¿”å›è¯¥è¡Œ
                    * - å¦‚æœæœåŠ¡å™¨æ–­å¼€ â†’ è¿”å› nullï¼ˆEOFï¼‰
                    * - å¦‚æœæœåŠ¡å™¨é•¿æ—¶é—´ä¸å‘æ•°æ® â†’ ä¸€ç›´é˜»å¡ï¼Œç›´åˆ° readTimeout è§¦å‘
                    */
                    val line = source.readUtf8Line() ?: break  // EOF â†’ æ­£å¸¸æ–­å¼€

                    // â­ ç©ºè¡Œè¡¨ç¤ºä¸€ä¸ª SSE äº‹ä»¶ç»“æŸ
                    if (line.isEmpty()) {
                        val data = dataBuilder.toString().trim()
                        if (data.isNotEmpty()) {
                            // NotificationHelper.sendError(context, "SSE: æ”¶åˆ°äº‹ä»¶ â†’ $currentEvent")
                            handleEvent(currentEvent, data)
                        }
                        currentEvent = null
                        dataBuilder = StringBuilder()
                        continue
                    }

                    // â­ è§£æ event: å’Œ data:
                    when {
                        line.startsWith("event:") -> {
                            currentEvent = line.removePrefix("event:").trim()
                        // NotificationHelper.sendError(context, "SSE: event = $currentEvent")
                        }

                        line.startsWith("data:") -> {
                            if (dataBuilder.isNotEmpty()) dataBuilder.append('\n')
                            dataBuilder.append(line.removePrefix("data:").trim())
                        }
                    }
                }

                NotificationHelper.sendError(context, "SSE: ä¼šè¯ç»“æŸï¼ˆæ­£å¸¸ EOF æˆ– scope å–æ¶ˆï¼‰")
            }

        } catch (e: SocketTimeoutException) {
            /**
            * â­ å…³é”®ç‚¹ï¼šä¸»åŠ¨æ–­å¼€
            *
            * å½“ OkHttp çš„ readTimeout åˆ°æ—¶ï¼š
            * - readUtf8Line() ä¼šè¢«å¼ºåˆ¶ä¸­æ–­
            * - OkHttp ä¼šæŠ›å‡º SocketTimeoutException
            *
            * è¿™æ­£æ˜¯æˆ‘ä»¬ç”¨æ¥æ¨¡æ‹Ÿâ€œæµè§ˆå™¨æ¯ 60 ç§’ä¸»åŠ¨æ–­å¼€â€çš„æœºåˆ¶ã€‚
            */
            NotificationHelper.sendError(context, "SSE: ä¼šè¯è¶…æ—¶ â†’ ä¸»åŠ¨æ–­å¼€ï¼ˆæ­£å¸¸ï¼‰")

        } catch (e: Exception) {
            // NotificationHelper.sendError(context, "SSE: å¼‚å¸¸æ–­å¼€ â†’ ${e.message}")
            throw e
        }
        // â­ è®°å½•ç»“æŸæ—¶é—´å¹¶è®¡ç®—ç§’æ•° 
        val connectEnd = System.currentTimeMillis() 
        val durationSec = (connectEnd - connectStart) / 1000
        NotificationHelper.sendError(context, "SSE: æŒç»­æ—¶é—´ ${durationSec} ç§’")
    }
```