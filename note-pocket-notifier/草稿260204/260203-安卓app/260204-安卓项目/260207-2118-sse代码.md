ä¸‹é¢æ˜¯ä¸€æ¬¡æ€§å®Œæ•´æ”¹åŠ¨ã€‚

---

### 1. æ–°å¢å®æ—¶é…ç½®å¸¸é‡ï¼ˆè¦†ç›–æ•´ä¸ªæ–‡ä»¶ï¼‰

**æ–‡ä»¶ï¼š** `app/src/main/java/com/pocket/notifier/config/Config.kt`

```kotlin
package com.pocket.notifier.config

/**
 * ================================
 * ğŸš© å¸¸æ”¹ä½ç½®ï¼ˆé›†ä¸­é…ç½®ï¼‰
 * ================================
 *
 * ä½ å¯ä»¥åœ¨è¿™é‡Œä¿®æ”¹ï¼š
 * - è½®è¯¢é—´éš”ï¼ˆç§’ï¼‰
 * - è¯·æ±‚è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
 * - è¯·æ±‚è·¯å¾„ï¼ˆAPI URLï¼‰
 * - å®æ—¶ SSE ç›¸å…³é…ç½®
 *
 * æ‰€æœ‰é…ç½®å‡ä¸º constï¼Œç¼–è¯‘æœŸå¸¸é‡ï¼Œä¾¿äºç»Ÿä¸€ç®¡ç†ã€‚
 */
object Config {

    /** è½®è¯¢é—´éš”ï¼ˆç§’ï¼‰ */
    const val POLLING_INTERVAL_SECONDS: Long = 300

    /** è¯·æ±‚è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ */
    const val REQUEST_TIMEOUT_SECONDS: Long = 10

    /** è½®è¯¢è¯·æ±‚è·¯å¾„ */
    const val REQUEST_URL: String =
        "https://uika.top/api/collections/messages/records?page=1&perPage=40&expand=author&sort=-created%2Cid&skipTotal=true"

    /** ç‚¹å‡»ä¸»å›¾ç‰‡æ—¶æ‰“å¼€çš„ç½‘å€ */
    const val CLICK_URL: String = "https://uika.top"

    /** SSE å®æ—¶è¿æ¥åœ°å€ï¼ˆGET /api/realtime & POST /api/realtimeï¼‰ */
    const val REALTIME_URL: String = "https://uika.top/api/realtime"

    /**
     * SSE è®¢é˜…å­—ç¬¦ä¸²
     *
     * å¯¹åº”ï¼š
     * "messages/*?options=%7B%22query%22%3A%7B%22expand%22%3A%22author%22%7D%7D"
     */
    const val REALTIME_SUBSCRIPTION: String =
        "messages/*?options=%7B%22query%22%3A%7B%22expand%22%3A%22author%22%7D%7D"

    /**
     * å•æ¬¡ SSE ä¼šè¯æ—¶é•¿ï¼ˆç§’ï¼‰
     *
     * æµè§ˆå™¨ç«¯æ˜¯çº¦ 2 åˆ†é’Ÿä¸»åŠ¨æ–­å¼€åé‡è¿ï¼Œè¿™é‡Œä¿æŒä¸€è‡´ã€‚
     */
    const val REALTIME_SESSION_SECONDS: Long = 120
}
```

---

### 2. æ–°å¢ SSE å®¢æˆ·ç«¯ï¼ˆæ–°æ–‡ä»¶ï¼‰

**æ–‡ä»¶ï¼š** `app/src/main/java/com/pocket/notifier/service/RealtimeClient.kt`

```kotlin
package com.pocket.notifier.service

import android.content.Context
import com.pocket.notifier.config.Config
import com.pocket.notifier.notification.NotificationHelper
import com.pocket.notifier.store.MessageStore
import com.pocket.notifier.store.StatusStore
import com.pocket.notifier.store.StoredMessage
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.withContext
import kotlinx.coroutines.withTimeoutOrNull
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONArray
import org.json.JSONObject
import java.io.IOException

/**
 * RealtimeClient â€” PocketBase SSE å®æ—¶å®¢æˆ·ç«¯
 *
 * èŒè´£ï¼š
 * - å»ºç«‹ GET /api/realtime é•¿è¿æ¥
 * - è§£æ SSE äº‹ä»¶æµï¼ˆPB_CONNECT + å®é™…äº‹ä»¶ï¼‰
 * - åœ¨ PB_CONNECT åå‘é€ POST /api/realtime è®¾ç½®è®¢é˜…
 * - å¯¹ action = "create" çš„äº‹ä»¶ï¼Œè½¬æ¢ä¸º StoredMessageï¼Œå†™å…¥ MessageStore å¹¶å‘é€šçŸ¥
 * - GET / POST æˆåŠŸä¸å¦å†™å…¥ StatusStore
 *
 * è¯´æ˜ï¼š
 * - ä½¿ç”¨ OkHttp æ‰‹åŠ¨è§£æ text/event-stream
 * - å•æ¬¡ä¼šè¯æ—¶é•¿ç”± Config.REALTIME_SESSION_SECONDS æ§åˆ¶ï¼ˆä¾‹å¦‚ 120 ç§’ï¼‰
 * - ä¼šè¯ç»“æŸæˆ–å¼‚å¸¸åè‡ªåŠ¨é‡è¿ï¼ˆå¸¦å°‘é‡å»¶è¿Ÿï¼‰
 */
class RealtimeClient(
    private val context: Context,
    private val client: OkHttpClient,
    private val scope: CoroutineScope
) {

    private var job: Job? = null

    fun start() {
        if (job == null || job?.isCancelled == true) {
            job = scope.launchRealtimeLoop()
        }
    }

    fun stop() {
        job?.cancel()
        job = null
    }

    private fun CoroutineScope.launchRealtimeLoop(): Job = this.launch(Dispatchers.IO) {
        while (isActive) {
            try {
                connectOnce()
                // åªè¦æœ¬æ¬¡ä¼šè¯å»ºç«‹å¹¶æ­£å¸¸ç»“æŸï¼Œå°±è®¤ä¸ºæ˜¯æˆåŠŸ
                StatusStore.setLastStatus(context, true)
            } catch (e: Exception) {
                StatusStore.setLastStatus(context, false)
                NotificationHelper.sendError(
                    context,
                    "Realtime error: ${e::class.java.simpleName}: ${e.message}"
                )
                // é¿å…ç–¯ç‹‚é‡è¿ï¼Œç¨å¾®ç­‰ä¸€ä¸‹
                delay(5_000)
            }
        }
    }

    /**
     * å•æ¬¡ SSE ä¼šè¯ï¼š
     * - å»ºç«‹ GET /api/realtime
     * - åœ¨ä¼šè¯æ—¶é—´çª—å£å†…æŒç»­è¯»å– SSE è¡Œ
     * - è¶…æ—¶ / EOF / å–æ¶ˆ å³ç»“æŸæœ¬æ¬¡ä¼šè¯ï¼Œå¤–å±‚å¾ªç¯è´Ÿè´£é‡è¿
     */
    private suspend fun connectOnce() {
        val request = Request.Builder()
            .url(Config.REALTIME_URL)
            .get()
            .build()

        client.newCall(request).execute().use { response ->
            if (!response.isSuccessful) {
                throw IOException("HTTP ${response.code} on realtime connect")
            }

            val body = response.body ?: throw IOException("Empty realtime body")
            val source = body.source()

            var currentEvent: String? = null
            var dataBuilder = StringBuilder()
            val startTime = System.currentTimeMillis()

            while (
                scope.isActive &&
                System.currentTimeMillis() - startTime <
                Config.REALTIME_SESSION_SECONDS * 1000
            ) {
                // è¯»ä¸€è¡Œï¼Œè®¾ç½®ä¸€ä¸ªå°è¶…æ—¶ï¼Œé¿å…æ°¸ä¹…å¡æ­»
                val line = withTimeoutOrNull(5_000) {
                    source.readUtf8Line()
                } ?: break // è¶…æ—¶æˆ– EOFï¼Œç»“æŸæœ¬æ¬¡ä¼šè¯

                if (line.isEmpty()) {
                    // ä¸€ä¸ªäº‹ä»¶ç»“æŸï¼Œæ´¾å‘
                    val data = dataBuilder.toString().trim()
                    if (data.isNotEmpty()) {
                        handleEvent(currentEvent, data)
                    }
                    currentEvent = null
                    dataBuilder = StringBuilder()
                    continue
                }

                when {
                    line.startsWith("event:") -> {
                        currentEvent = line.removePrefix("event:").trim()
                    }

                    line.startsWith("data:") -> {
                        if (dataBuilder.isNotEmpty()) dataBuilder.append('\n')
                        dataBuilder.append(line.removePrefix("data:").trim())
                    }
                }
            }
        }
    }

    /**
     * å¤„ç†å•ä¸ª SSE äº‹ä»¶
     *
     * - event == "PB_CONNECT" â†’ è§£æ clientId â†’ POST /api/realtime è®¾ç½®è®¢é˜…
     * - å…¶ä»–äº‹ä»¶ï¼šå¦‚æœ data ä¸­æœ‰ action == "create" â†’ è§£æ record â†’ å†™å…¥æœ¬åœ°å¹¶å‘é€šçŸ¥
     */
    private suspend fun handleEvent(event: String?, data: String) {
        if (event == "PB_CONNECT") {
            val json = JSONObject(data)
            val clientId = json.getString("clientId")
            sendSubscription(clientId)
            // è®¢é˜…æˆåŠŸä¹Ÿè§†ä¸ºæˆåŠŸ
            StatusStore.setLastStatus(context, true)
            return
        }

        // å…¶ä»–äº‹ä»¶ï¼šå°è¯•è§£æ action
        val json = JSONObject(data)
        if (!json.has("action")) return

        val action = json.getString("action")
        if (action != "create") return

        val record = json.getJSONObject("record")
        val expand = record.getJSONObject("expand").getJSONObject("author")

        val message = StoredMessage(
            id = record.getString("id"),
            created = record.getString("created"),
            content = record.getString("content"),
            authorName = expand.optString("name", ""),
            authorUsername = expand.optString("username", "")
        )

        // é¿å…é‡å¤ï¼šå¦‚æœæœ¬åœ°å·²ç»æœ‰è¯¥ idï¼Œåˆ™å¿½ç•¥
        val stored = MessageStore.getMessages(context)
        val exists = stored.any { it.id == message.id }
        if (!exists) {
            // å†™å…¥æœ¬åœ°ï¼ˆä¿æŒä¸è½®è¯¢ä¸€è‡´ï¼šå‡åºè¿½åŠ ï¼‰
            MessageStore.addMessages(context, listOf(message))
            // å•æ¡æ¶ˆæ¯é€šçŸ¥
            NotificationHelper.sendNewMessage(context, message)
        }
    }

    /**
     * åœ¨ PB_CONNECT åè°ƒç”¨ï¼š
     * - POST /api/realtime
     * - Body:
     *   {
     *     "clientId": "...",
     *     "subscriptions": [
     *       Config.REALTIME_SUBSCRIPTION
     *     ]
     *   }
     */
    private suspend fun sendSubscription(clientId: String) {
        val bodyJson = JSONObject().apply {
            put("clientId", clientId)
            put(
                "subscriptions",
                JSONArray().apply {
                    put(Config.REALTIME_SUBSCRIPTION)
                }
            )
        }

        val mediaType = "application/json; charset=utf-8".toMediaType()
        val body = bodyJson.toString().toRequestBody(mediaType)

        val request = Request.Builder()
            .url(Config.REALTIME_URL)
            .post(body)
            .build()

        withContext(Dispatchers.IO) {
            client.newCall(request).execute().use { response ->
                if (!response.isSuccessful) {
                    throw IOException("HTTP ${response.code} on realtime subscribe")
                }
            }
        }
    }
}
```

---

### 3. è½®è¯¢æœåŠ¡ä¸­æ¥å…¥ SSEï¼ˆè¦†ç›–æ•´ä¸ªæ–‡ä»¶ï¼‰

**æ–‡ä»¶ï¼š** `app/src/main/java/com/pocket/notifier/service/PollingService.kt`

```kotlin
package com.pocket.notifier.service

import android.app.Notification
import android.app.Service
import android.content.Intent
import android.os.IBinder
import androidx.core.app.NotificationCompat
import com.pocket.notifier.R
import com.pocket.notifier.config.Config
import com.pocket.notifier.notification.NotificationHelper
import com.pocket.notifier.store.StatusStore
import com.pocket.notifier.store.MessageStore
import com.pocket.notifier.store.StoredMessage
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import okhttp3.OkHttpClient
import okhttp3.Request
import org.json.JSONObject
import java.util.concurrent.TimeUnit

class PollingService : Service() {

    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    private val client by lazy {
        OkHttpClient.Builder()
            .connectTimeout(Config.REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS)
            .readTimeout(Config.REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS)
            .writeTimeout(Config.REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS)
            .build()
    }

    /** SSE å®æ—¶å®¢æˆ·ç«¯ */
    private lateinit var realtimeClient: RealtimeClient

    override fun onCreate() {
        super.onCreate()

        // åˆå§‹åŒ–é€šçŸ¥æ¸ é“
        NotificationHelper.initChannels(this)

        // å‰å°æœåŠ¡å¸¸é©»é€šçŸ¥
        startForeground(1, createForegroundNotification())

        // å¯åŠ¨è½®è¯¢å¾ªç¯
        startPollingLoop()

        // å¯åŠ¨ SSE å®æ—¶å¾ªç¯
        realtimeClient = RealtimeClient(this, client, scope)
        realtimeClient.start()
    }

    override fun onBind(intent: Intent?): IBinder? = null

    override fun onDestroy() {
        super.onDestroy()
        // åœæ­¢ SSE
        if (::realtimeClient.isInitialized) {
            realtimeClient.stop()
        }
        // å–æ¶ˆæ‰€æœ‰åç¨‹
        scope.cancel()
    }

    /** å‰å°æœåŠ¡é€šçŸ¥ï¼ˆå¸¸é©»ï¼‰ */
    private fun createForegroundNotification(): Notification {
        return NotificationCompat.Builder(this, NotificationHelper.CHANNEL_FOREGROUND)
            .setContentTitle("Notifier is running in the background.")
            .setSmallIcon(R.drawable.ic_notify)
            .setOngoing(true)
            .build()
    }

    /** è½®è¯¢å¾ªç¯ï¼ˆä¿ç•™åŸæœ‰é€»è¾‘ï¼Œç”¨äºå…œåº•é˜²æ¼æ¶ˆæ¯ï¼‰ */
    private fun startPollingLoop() {
        scope.launch {
            while (isActive) {
                performRequest()
                delay(Config.POLLING_INTERVAL_SECONDS * 1000)
            }
        }
    }

    // å¹¿æ’­ä»¥å®ç°ä¸»å›¾å®æ—¶æ›´æ–°
    private fun sendStatusBroadcast() {
        val intent = Intent("NOTIFIER_STATUS_UPDATED")
        sendBroadcast(intent)
    }

    /** æ‰§è¡Œä¸€æ¬¡ HTTP è½®è¯¢è¯·æ±‚ï¼ˆGET /api/collections/messages/records...ï¼‰ */
    private fun performRequest() {

        // æ„å»º GET è¯·æ±‚ï¼ˆURL ä» Config è¯»å–ï¼Œé›†ä¸­é…ç½®ï¼‰
        val request = Request.Builder()
            .url(Config.REQUEST_URL)
            .get()
            .build()

        try {
            // åŒæ­¥æ‰§è¡Œ HTTP è¯·æ±‚ï¼ˆåœ¨ IO çº¿ç¨‹ä¸­ï¼Œä¸é˜»å¡ä¸»çº¿ç¨‹ï¼‰
            client.newCall(request).execute().use { response ->

                // é 2xx çŠ¶æ€ç  â†’ è§†ä¸ºè¯·æ±‚å¤±è´¥
                if (!response.isSuccessful) {
                    StatusStore.setLastStatus(this@PollingService, false)
                    NotificationHelper.sendError(this, "HTTP ${response.code}")
                    return
                }

                // è¯»å–å“åº” bodyï¼ˆstring() ä¼šä¸€æ¬¡æ€§è¯»å–å¹¶å…³é—­æµï¼‰
                val body = response.body?.string() ?: return

                // è§£æ PocketBase æ ‡å‡† JSON ç»“æ„
                val json = JSONObject(body)
                val items = json.getJSONArray("items")
                val perPage = json.getInt("perPage") // ç”¨äºé€šçŸ¥æ˜¾ç¤º

                // å°† JSON è½¬æ¢ä¸º StoredMessage åˆ—è¡¨
                val received = mutableListOf<StoredMessage>()
                for (i in 0 until items.length()) {
                    val obj = items.getJSONObject(i)
                    val expand = obj.getJSONObject("expand").getJSONObject("author")

                    received.add(
                        StoredMessage(
                            id = obj.getString("id"),
                            created = obj.getString("created"),
                            content = obj.getString("content"),
                            authorName = expand.getString("name"),
                            authorUsername = expand.getString("username")
                        )
                    )
                }

                // PocketBase è¿”å›çš„ items æ˜¯æŒ‰ created DESC æ’åºï¼ˆæœ€æ–°åœ¨å‰ï¼‰
                // æœ¬åœ°å­˜å‚¨æ˜¯ ASCï¼ˆæ—§ â†’ æ–°ï¼‰
                val stored = MessageStore.getMessages(this)
                val storedIds = stored.map { it.id }.toSet() // ä½¿ç”¨ Set åŠ é€ŸæŸ¥é‡

                // è¿‡æ»¤å‡ºæœ¬åœ°ä¸å­˜åœ¨çš„æ–°æ¶ˆæ¯
                val newMessages = received.filter { it.id !in storedIds }

                // å¦‚æœæœ‰æ–°æ¶ˆæ¯ â†’ å‘é€šçŸ¥ + å†™å…¥æœ¬åœ°
                if (newMessages.isNotEmpty()) {

                    // é€šçŸ¥ä½¿ç”¨ DESC é¡ºåºï¼ˆæœ€æ–°åœ¨å‰ï¼‰
                    NotificationHelper.sendNewMessages(this, newMessages, perPage)

                    // å†™å…¥æœ¬åœ°å‰æŒ‰ created å‡åºæ’åºï¼ˆä¿æŒå­˜å‚¨ä¸€è‡´æ€§ï¼‰
                    MessageStore.addMessages(this, newMessages.sortedBy { it.created })
                }

                // è¯·æ±‚æˆåŠŸï¼ˆåŒ…æ‹¬â€œæ— æ–°æ¶ˆæ¯â€è¿™ç§æ­£å¸¸æƒ…å†µï¼‰
                StatusStore.setLastStatus(this@PollingService, true)
            }

        } catch (e: Exception) {

            // æ•è·æ‰€æœ‰å¼‚å¸¸ â†’ ä¸å´©æºƒ â†’ æ ‡è®°å¤±è´¥
            StatusStore.setLastStatus(this@PollingService, false)

            // å‘é€é”™è¯¯é€šçŸ¥ï¼ˆåŒ…å«å¼‚å¸¸ç±»å‹ + messageï¼Œä¾¿äºè°ƒè¯•ï¼‰
            NotificationHelper.sendError(this, "${e::class.java.simpleName}: ${e.message}")
        }

        // æ— è®ºæˆåŠŸå¤±è´¥éƒ½å¹¿æ’­çŠ¶æ€ â†’ UI å¯åˆ·æ–°
        sendStatusBroadcast()
    }
}
```

---

å¦‚æœä½ æƒ³ä¸‹ä¸€æ­¥ä¸€èµ·åšã€Œåªç”¨ SSE æ—¶çš„è¡Œä¸ºçº¦æŸã€æˆ–ã€Œå¦‚ä½•åœ¨æ—¥å¿—é‡ŒåŒºåˆ†è½®è¯¢ vs SSE é”™è¯¯ã€ï¼Œæˆ‘ä»¬å¯ä»¥å†ç»†åŒ–ä¸€å±‚åè®®ã€‚