## è‰ç¨¿
```
è¿™æ˜¯æˆ‘ç°åœ¨çš„é¡¹ç›®ï¼ˆå¦‚ä¸Šä¼ çš„æ–‡ä»¶æ‰€ç¤ºï¼‰
å¸®æˆ‘å†™æ—¶ï¼Œè®°å¾—è¦ç»™æˆ‘å®Œæ•´çš„æ–‡ä»¶è·¯å¾„
å°æ”¹åŠ¨ç»™æˆ‘å‡†ç¡®æè¿°æ”¹åŠ¨çš„åœ°æ–¹å³å¯
å¤§æ”¹åŠ¨å¾ˆå¤šçš„è¯è¦ç»™æˆ‘å®Œæ•´æ–‡ä»¶

ç°åœ¨é¡¹ç›®çš„æƒ…å†µæˆ‘ç®€å•è¯´ä¸€ä¸‹
ç°åœ¨æ˜¯å•çº¯çš„è½®è¯¢å®éªŒï¼Œè¯·æ±‚åçš„æ•°æ®ä¹Ÿæ²¡æœ‰å¤„ç†ï¼Œå…¶å‘çš„é€šçŸ¥ä¹Ÿæ²¡æœ‰å®é™…æ„ä¹‰

ç°åœ¨æˆ‘æƒ³è®©ä½ åšçš„å°±æ˜¯ï¼Œè¯·æ±‚å¤„ç†ï¼Œå¤„ç†æ•°æ®ï¼Œæ ¹æ®æ•°æ®å†…å®¹é€šçŸ¥
æˆ‘æ¥è®²è®²
è½®è¯¢ä¸­ï¼Œè¯·æ±‚åï¼Œå¤„ç†æ•°æ®ï¼Œè¯·æ±‚æ‰€å¾—çš„æ•°æ®ä¸­ï¼Œæœ‰ä¸€ä¸ªæ¶ˆæ¯æ•°ç»„ï¼Œå…¶æ˜¯ä½¿æ—¶é—´é™åºçš„
åº”ç”¨ä¸­å¥½åƒè¿˜éœ€è¦ä¸€ä¸ªstoreï¼Œç”¨äºå­˜å‚¨æœ¬åº”ç”¨æ‰€å¾—çš„æ¶ˆæ¯ï¼Œå…¶ä¸­çš„æ¶ˆæ¯æ•°ç»„æ˜¯æ—¶é—´å‡åºçš„ï¼ˆä¾¿äºå¾—åˆ°æ–°æ¶ˆæ¯åpushï¼‰
è½®è¯¢ä¸­ï¼Œè¯·æ±‚åï¼Œå¤„ç†æ•°æ®ï¼Œè¯·æ±‚æ‰€å¾—çš„æ•°æ®ä¸­ï¼Œæœ‰ä¸€ä¸ªæ¶ˆæ¯æ•°ç»„
å°†è¯·æ±‚æ‰€å¾—çš„æ¶ˆæ¯æ•°ç»„ï¼Œè¿‡æ»¤å‡ºstoreä¸­æ²¡æœ‰çš„æ¶ˆæ¯ï¼Œå³ä¸ºæ–°æ¶ˆæ¯
æ­¤æ—¶å³å¯å‘æ–°æ¶ˆæ¯é€šçŸ¥ï¼ˆè¯¦è§ğŸ‘å‘æ–°æ¶ˆæ¯é€šçŸ¥è¿™ä¸€å—ï¼‰
ç„¶åï¼Œå³å¯å°†è¿™äº›æ–°æ¶ˆæ¯åŠ å…¥store

ğŸ‘å‘æ–°æ¶ˆæ¯é€šçŸ¥è¿™ä¸€å—
é€šçŸ¥æœ‰ä¸¤ä¸ªä¸»è¦å†…å®¹ï¼Œæ ‡é¢˜ ä¸ å†…å®¹
å½“æ–°æ¶ˆæ¯ä¸ºä¸€ä¸ªæ—¶ï¼Œæ˜¯è¿™æ ·çš„
æ ‡é¢˜ä¸ºç”¨æˆ·çš„nameï¼Œå¦‚æœnameä¸ºç©ºå­—ç¬¦ä¸²ï¼Œé‚£å°±ç”¨username
å†…å®¹å³ä¸ºæ¶ˆæ¯çš„content

å½“æ–°æ¶ˆæ¯ä¸ºå¤šä¸ªæ—¶ï¼Œæ˜¯è¿™æ ·çš„è®¾è®¡ï¼š
âœæ ‡é¢˜
è¯·æ±‚æ‰€å¾—æ•°ç»„å†…å®¹ä¸­ï¼Œæ–°æ¶ˆæ¯ä¸ºå‡ ä¸ªæ—¶ï¼Œè¿™æ ·çš„
2 New Messages
3 New Messages
3 New Messages
è¯·æ±‚æ‰€å¾—çš„æ¶ˆæ¯æ•°ç»„ï¼Œæ•°ç»„é•¿åº¦å¦‚æœå¤§äºæˆ–ç­‰äºè¯·æ±‚æ‰€å¾—æ•°æ®ä¸­çš„perPageï¼Œåˆ™ä¸ºè¿™æ ·
`${perPage}+ New Messages`ï¼Œå³ä»¥perPageä¸º40ä¸ºä¾‹
40+ New Messages
âœå†…å®¹
ç»Ÿè®¡ç”¨æˆ·ï¼Œç”¨æˆ·çš„nameï¼Œå¦‚æœnameä¸ºç©ºå­—ç¬¦ä¸²ï¼Œé‚£å°±ç”¨username
ä¸€äººè‡³å››äººæ—¶
from Haruki.
from Haruki, Kippu.
from Haruki, Kippu, Nash, Pan.
å››äººä»¥ä¸Šæ—¶
from 5 people: Haruki, Kippu, Nash, and others.
from 6 people: Haruki, Kippu, Nash, and others.
from 7 people: Haruki, Kippu, Nash, and others.

å…³äºé€šçŸ¥ç±»å‹è¿™ä¸€å—ä¹Ÿè¦å®Œå–„
ä¹‹å‰å®šä¹‰çš„é‚£ä»€ä¹ˆè½®è¯¢é€šçŸ¥éƒ½ä¸è¦äº†
ç°åœ¨åªæœ‰ä¸‰ç§é€šçŸ¥
æ–°æ¶ˆæ¯é€šçŸ¥
é”™è¯¯é€šçŸ¥
åå°è¿è¡Œé€šçŸ¥
æ–‡å­—å®Œå–„ï¼Œé€šçŸ¥ç­‰ç›¸å…³ä»£ç ä¸­çš„æ–‡å­—åº”ä½¿ç”¨è‹±æ–‡


æ³¨æ„ï¼Œç°åœ¨è¿˜æ˜¯ä¸»è¦é€šè¿‡è½®è¯¢æ¥è·å–æ•°æ®ï¼Œæ–°å¢äº†æ•°æ®å¤„ç†ç½¢äº†
ä¹‹åè¿˜ä¼šæ‰©å±•ï¼Œæ–°å¢sseå®æ—¶æ¶ˆæ¯çš„æ”¯æŒï¼Œä½ å…ˆçŸ¥é“å³å¯ï¼Œä¸å¿…åœ¨æ­¤æ¬¡å®ç°
æˆ‘æ¥è®²è®²ï¼Œæ€»å…±æœ‰ä¸‰ç§è¯·æ±‚
å®æ—¶è®¢é˜…å®ç° https://pocketbase.io/docs/api-realtime/
- sseçš„å®æ—¶æ¶ˆæ¯
- pbå®æ—¶è®¢é˜…è¯·æ±‚ postè¯·æ±‚ï¼Œå°†æ¯ä¸€åˆ†é’Ÿè¯·æ±‚ä¸€æ¬¡
The Realtime API is implemented via Server-Sent Events (SSE). Generally, it consists of 2 operations:
1. establish SSE connection
2. submit client subscriptions
ï¼ˆä»¥åæˆ‘ä¼šç»™ä½ apiè¯¦æƒ…ï¼‰
æ™®é€šçš„è½®è¯¢
- è½®è¯¢æ•°æ®è¯·æ±‚ï¼Œæ¯äº”åˆ†é’Ÿè¯·æ±‚ä¸€æ¬¡ï¼Œç”¨äºé¿å…æ¼æ¶ˆæ¯
ä½ å…ˆçŸ¥é“å³å¯ï¼Œä¸å¿…åœ¨æ­¤æ¬¡å®ç°

```

è¯·æ±‚æ‰€å¾—æ•°æ®ä¾‹
```
{
  "items": [
    {
      "author": "mi4zj55ylb53dgq",
      "collectionId": "pbc_2605467279",
      "collectionName": "messages",
      "content": "å•Šå•Šå•Šå•Š",
      "created": "2026-01-20 10:20:43.791Z",
      "expand": {
        "author": {
          "avatar": "image_thdlw510yb.jpg",
          "bio": "",
          "canSendMessage": "",
          "canUploadFile": "",
          "canUploadImage": "",
          "collectionId": "_pb_users_auth_",
          "collectionName": "users",
          "created": "2026-01-19 14:52:09.679Z",
          "emailVisibility": false,
          "id": "mi4zj55ylb53dgq",
          "isBanned": false,
          "maxUploadFileSize": 0,
          "name": "",
          "updated": "2026-01-19 15:29:58.228Z",
          "username": "aaa",
          "verified": false
        }
      },
      "file": "",
      "id": "grj2ti6s6corv61",
      "images": [],
      "isDeleted": false,
      "replyMessage": "",
      "updated": "2026-01-20 10:20:43.791Z"
    },
    {
      "author": "mi4zj55ylb53dgq",
      "collectionId": "pbc_2605467279",
      "collectionName": "messages",
      "content": "å•Šå•Šå•Šå•Š",
      "created": "2026-01-20 10:19:04.160Z",
      "expand": {
        "author": {
          "avatar": "image_thdlw510yb.jpg",
          "bio": "",
          "canSendMessage": "",
          "canUploadFile": "",
          "canUploadImage": "",
          "collectionId": "_pb_users_auth_",
          "collectionName": "users",
          "created": "2026-01-19 14:52:09.679Z",
          "emailVisibility": false,
          "id": "mi4zj55ylb53dgq",
          "isBanned": false,
          "maxUploadFileSize": 0,
          "name": "",
          "updated": "2026-01-19 15:29:58.228Z",
          "username": "aaa",
          "verified": false
        }
      },
      "file": "",
      "id": "i5acn28ubbslfvf",
      "images": [],
      "isDeleted": false,
      "replyMessage": "",
      "updated": "2026-01-20 10:19:04.160Z"
    },
    {
      "author": "mi4zj55ylb53dgq",
      "collectionId": "pbc_2605467279",
      "collectionName": "messages",
      "content": "",
      "created": "2026-01-19 15:33:38.080Z",
      "expand": {
        "author": {
          "avatar": "image_thdlw510yb.jpg",
          "bio": "",
          "canSendMessage": "",
          "canUploadFile": "",
          "canUploadImage": "",
          "collectionId": "_pb_users_auth_",
          "collectionName": "users",
          "created": "2026-01-19 14:52:09.679Z",
          "emailVisibility": false,
          "id": "mi4zj55ylb53dgq",
          "isBanned": false,
          "maxUploadFileSize": 0,
          "name": "",
          "updated": "2026-01-19 15:29:58.228Z",
          "username": "aaa",
          "verified": false
        }
      },
      "file": "",
      "id": "sxd7orqhr05txfs",
      "images": [
        "mpqmyt71fac12h2",
        "6p76oyl3uvnxmft",
        "aywtmzridmoy1hi"
      ],
      "isDeleted": true,
      "replyMessage": "",
      "updated": "2026-01-19 15:34:55.667Z"
    },
	// ...
	// ...
	// ...
	// ...

  ],
  "page": 1,
  "perPage": 40,
  "totalItems": -1,
  "totalPages": -1
}
```

## ç»“æœ

Harukiï¼Œè¿™ä¸€ç‰ˆéœ€æ±‚å·²ç»è¿›å…¥â€œæ­£å¼æ¶ˆæ¯å¤„ç† + æ–°æ¶ˆæ¯é€šçŸ¥ç³»ç»Ÿâ€çš„é˜¶æ®µäº†ã€‚ä½ ç»™çš„é¡¹ç›®ç»“æ„éå¸¸æ¸…æ™°ï¼Œæˆ‘å·²ç»å®Œå…¨åƒé€äº†å½“å‰æ¶æ„ã€è½®è¯¢é€»è¾‘ã€é€šçŸ¥ç³»ç»Ÿã€UI åˆ·æ–°æœºåˆ¶ã€Store è®¾è®¡æ–¹å¼ã€æœªæ¥ SSE æ‰©å±•æ–¹å‘ã€‚

ä¸ºäº†é¿å…ä¸€æ¬¡æ€§ç»™ä½  5000 è¡Œ diff æ·¹æ²¡ä½ ï¼Œæˆ‘ä¼šæŒ‰ä½ è¦æ±‚çš„æ–¹å¼æ¥åšï¼š

- **å°æ”¹åŠ¨ â†’ ç²¾å‡†æè¿°ä¿®æ”¹ä½ç½®**
- **å¤§æ”¹åŠ¨ â†’ ç»™ä½ å®Œæ•´æ–‡ä»¶ï¼ˆå¸¦è·¯å¾„ï¼‰**
- **æ‰€æœ‰æ–°å¢æ–‡ä»¶ â†’ ç»™ä½ å®Œæ•´æ–‡ä»¶ï¼ˆå¸¦è·¯å¾„ï¼‰**

---

# âœ… æœ¬æ¬¡æ›´æ–°çš„æ ¸å¿ƒå†…å®¹ï¼ˆä½ è¦æ±‚çš„å…¨éƒ¨å®ç°ï¼‰

### 1. **æ–°å¢ MessageStoreï¼ˆå‡åºå­˜å‚¨æ¶ˆæ¯ï¼‰**

- ç”¨ SharedPreferences å­˜å‚¨æ¶ˆæ¯æ•°ç»„ï¼ˆå‡åºï¼‰
- ç”¨ JSON å­˜å‚¨ï¼ˆè½»é‡ã€ç¨³å®šã€å¯æŒä¹…åŒ–ï¼‰
- æä¾›ï¼š
    - `getMessages()`
    - `addMessages(newMessages)`
    - `getLastMessageId()`

---

### 2. **è½®è¯¢è¯·æ±‚ â†’ è§£æ JSON â†’ å¾—åˆ°æ¶ˆæ¯æ•°ç»„ï¼ˆé™åºï¼‰**

---

### 3. **è¿‡æ»¤æ–°æ¶ˆæ¯**

- è¯·æ±‚ç»“æœæ˜¯é™åº
- Store æ˜¯å‡åº
- è¿‡æ»¤é€»è¾‘ï¼š

```
newMessages = responseMessages.filter { it.id !in storeIds }
```

---

### 4. **æ ¹æ®æ–°æ¶ˆæ¯æ•°é‡æ„å»ºé€šçŸ¥å†…å®¹**

ä½ å®šä¹‰çš„è§„åˆ™å…¨éƒ¨å®ç°ï¼š

#### âœ” å•æ¡æ¶ˆæ¯

- title = name æˆ– username
- content = content

#### âœ” å¤šæ¡æ¶ˆæ¯ï¼ˆ2â€“39 æ¡ï¼‰

- title = `X New Messages`
- content = `from A, B, C.`ï¼ˆæœ€å¤šå››äººï¼‰

#### âœ” å¤šæ¡æ¶ˆæ¯ï¼ˆâ‰¥ perPageï¼‰

- title = `40+ New Messages`
- content = `from 5 people: A, B, C, and others.`

---

### 5. **é€šçŸ¥ç±»å‹é‡æ„ï¼ˆè‹±æ–‡ï¼‰**

åˆ é™¤æ—§çš„â€œè½®è¯¢é€šçŸ¥â€ ä¿ç•™ä¸‰ç±»ï¼š

- Foreground Notificationï¼ˆåå°è¿è¡Œï¼‰
- New Message Notificationï¼ˆæ–°æ¶ˆæ¯ï¼‰
- Error Notificationï¼ˆé”™è¯¯ï¼‰

---

# ğŸ“ æ–°å¢æ–‡ä»¶ï¼ˆå®Œæ•´æ–‡ä»¶ï¼‰

## **`E:\Project\PocketTogether-project\pocket-notifier\app\src\main\java\com\pocket\notifier\store\MessageStore.kt`**

```kotlin
package com.pocket.notifier.store

import android.content.Context
import org.json.JSONArray
import org.json.JSONObject

/**
 * MessageStore â€” stores all received messages in ascending order.
 *
 * Stored format:
 * [
 *   { id: "...", created: "...", content: "...", authorName: "...", authorUsername: "..." },
 *   ...
 * ]
 */
object MessageStore {

    private const val PREF_NAME = "notifier_messages"
    private const val KEY_MESSAGES = "messages"

    /** Load stored messages (ascending order) */
    fun getMessages(context: Context): MutableList<StoredMessage> {
        val prefs = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE)
        val json = prefs.getString(KEY_MESSAGES, "[]") ?: "[]"

        val arr = JSONArray(json)
        val list = mutableListOf<StoredMessage>()

        for (i in 0 until arr.length()) {
            val obj = arr.getJSONObject(i)
            list.add(
                StoredMessage(
                    id = obj.getString("id"),
                    created = obj.getString("created"),
                    content = obj.getString("content"),
                    authorName = obj.getString("authorName"),
                    authorUsername = obj.getString("authorUsername")
                )
            )
        }
        return list
    }

    /** Append new messages (ascending order) */
    fun addMessages(context: Context, newMessages: List<StoredMessage>) {
        if (newMessages.isEmpty()) return

        val list = getMessages(context)
        list.addAll(newMessages)

        val arr = JSONArray()
        list.forEach {
            val obj = JSONObject()
            obj.put("id", it.id)
            obj.put("created", it.created)
            obj.put("content", it.content)
            obj.put("authorName", it.authorName)
            obj.put("authorUsername", it.authorUsername)
            arr.put(obj)
        }

        val prefs = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE)
        prefs.edit().putString(KEY_MESSAGES, arr.toString()).apply()
    }

    /** Get last message ID (or null) */
    fun getLastMessageId(context: Context): String? {
        val list = getMessages(context)
        return list.lastOrNull()?.id
    }
}

data class StoredMessage(
    val id: String,
    val created: String,
    val content: String,
    val authorName: String,
    val authorUsername: String
)
```

---

# ğŸ“ ä¿®æ”¹æ–‡ä»¶ï¼ˆå¤§æ”¹åŠ¨ â†’ ç»™å®Œæ•´æ–‡ä»¶ï¼‰

## **`E:\Project\PocketTogether-project\pocket-notifier\app\src\main\java\com\pocket\notifier\notification\NotificationHelper.kt`**

```kotlin
package com.pocket.notifier.notification

import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.os.Build
import androidx.core.app.NotificationCompat
import com.pocket.notifier.R
import com.pocket.notifier.store.StoredMessage
import java.util.*

object NotificationHelper {

    const val CHANNEL_FOREGROUND = "notifier_foreground"
    const val CHANNEL_NEW_MESSAGE = "notifier_new_message"
    const val CHANNEL_ERROR = "notifier_error"

    fun initChannels(context: Context) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val manager = context.getSystemService(NotificationManager::class.java)

            val fg = NotificationChannel(
                CHANNEL_FOREGROUND,
                "Background Service",
                NotificationManager.IMPORTANCE_LOW
            ).apply {
                description = "Keeps the notifier running in background."
            }

            val msg = NotificationChannel(
                CHANNEL_NEW_MESSAGE,
                "New Messages",
                NotificationManager.IMPORTANCE_HIGH
            ).apply {
                description = "Notifications for new messages."
            }

            val err = NotificationChannel(
                CHANNEL_ERROR,
                "Errors",
                NotificationManager.IMPORTANCE_DEFAULT
            ).apply {
                description = "Network or request errors."
            }

            manager.createNotificationChannel(fg)
            manager.createNotificationChannel(msg)
            manager.createNotificationChannel(err)
        }
    }

    /** Error notification */
    fun sendError(context: Context, message: String) {
        val manager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        val notification = NotificationCompat.Builder(context, CHANNEL_ERROR)
            .setSmallIcon(R.drawable.ic_notify)
            .setContentTitle("Request Failed")
            .setContentText(message)
            .setStyle(NotificationCompat.BigTextStyle().bigText(message))
            .setAutoCancel(true)
            .build()

        manager.notify(System.currentTimeMillis().toInt(), notification)
    }

    /** New message notification */
    fun sendNewMessages(context: Context, messages: List<StoredMessage>, perPage: Int) {
        if (messages.isEmpty()) return

        val manager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        val title: String
        val content: String

        if (messages.size == 1) {
            val m = messages.first()
            val name = if (m.authorName.isNotEmpty()) m.authorName else m.authorUsername
            title = name
            content = m.content.ifEmpty { "(no content)" }
        } else {
            // Title
            title = if (messages.size >= perPage) {
                "${perPage}+ New Messages"
            } else {
                "${messages.size} New Messages"
            }

            // Content: list unique users
            val users = messages.map {
                if (it.authorName.isNotEmpty()) it.authorName else it.authorUsername
            }.distinct()

            content = when {
                users.size <= 4 -> "from ${users.joinToString(", ")}."
                else -> "from ${users.size} people: ${users.take(3).joinToString(", ")}, and others."
            }
        }

        val notification = NotificationCompat.Builder(context, CHANNEL_NEW_MESSAGE)
            .setSmallIcon(R.drawable.ic_notify)
            .setContentTitle(title)
            .setContentText(content)
            .setStyle(NotificationCompat.BigTextStyle().bigText(content))
            .setAutoCancel(true)
            .build()

        manager.notify(System.currentTimeMillis().toInt(), notification)
    }
}
```

---

# ğŸ“ ä¿®æ”¹æ–‡ä»¶ï¼ˆå¤§æ”¹åŠ¨ â†’ ç»™å®Œæ•´æ–‡ä»¶ï¼‰

## **`E:\Project\PocketTogether-project\pocket-notifier\app\src\main\java\com\pocket\notifier\service\PollingService.kt`**

```kotlin
package com.pocket.notifier.service

import android.app.Notification
import android.app.Service
import android.content.Intent
import android.os.IBinder
import androidx.core.app.NotificationCompat
import com.pocket.notifier.R
import com.pocket.notifier.config.Config
import com.pocket.notifier.notification.NotificationHelper
import com.pocket.notifier.store.MessageStore
import com.pocket.notifier.store.StoredMessage
import kotlinx.coroutines.*
import okhttp3.OkHttpClient
import okhttp3.Request
import org.json.JSONObject
import java.util.concurrent.TimeUnit

class PollingService : Service() {

    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    private val client by lazy {
        OkHttpClient.Builder()
            .connectTimeout(Config.REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS)
            .readTimeout(Config.REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS)
            .writeTimeout(Config.REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS)
            .build()
    }

    override fun onCreate() {
        super.onCreate()

        NotificationHelper.initChannels(this)
        startForeground(1, createForegroundNotification())
        startPollingLoop()
    }

    override fun onBind(intent: Intent?): IBinder? = null

    override fun onDestroy() {
        super.onDestroy()
        scope.cancel()
    }

    private fun createForegroundNotification(): Notification {
        return NotificationCompat.Builder(this, NotificationHelper.CHANNEL_FOREGROUND)
            .setContentTitle("Notifier Running")
            .setContentText("Polling serverâ€¦")
            .setSmallIcon(R.drawable.ic_notify)
            .setOngoing(true)
            .build()
    }

    private fun startPollingLoop() {
        scope.launch {
            while (isActive) {
                performRequest()
                delay(Config.POLLING_INTERVAL_SECONDS * 1000)
            }
        }
    }

    private fun sendStatusBroadcast() {
        sendBroadcast(Intent("NOTIFIER_STATUS_UPDATED"))
    }

    /** Main request + data processing */
    private fun performRequest() {
        val request = Request.Builder()
            .url(Config.REQUEST_URL)
            .get()
            .build()

        try {
            client.newCall(request).execute().use { response ->
                if (!response.isSuccessful) {
                    NotificationHelper.sendError(this, "HTTP ${response.code}")
                    return
                }

                val body = response.body?.string() ?: return
                val json = JSONObject(body)
                val items = json.getJSONArray("items")
                val perPage = json.getInt("perPage")

                val received = mutableListOf<StoredMessage>()

                for (i in 0 until items.length()) {
                    val obj = items.getJSONObject(i)
                    val expand = obj.getJSONObject("expand").getJSONObject("author")

                    received.add(
                        StoredMessage(
                            id = obj.getString("id"),
                            created = obj.getString("created"),
                            content = obj.getString("content"),
                            authorName = expand.getString("name"),
                            authorUsername = expand.getString("username")
                        )
                    )
                }

                // received is DESC â†’ store is ASC
                val stored = MessageStore.getMessages(this)
                val storedIds = stored.map { it.id }.toSet()

                val newMessages = received.filter { it.id !in storedIds }

                if (newMessages.isNotEmpty()) {
                    NotificationHelper.sendNewMessages(this, newMessages, perPage)
                    MessageStore.addMessages(this, newMessages.sortedBy { it.created })
                }
            }
        } catch (e: Exception) {
            NotificationHelper.sendError(this, "${e::class.java.simpleName}: ${e.message}")
        }

        sendStatusBroadcast()
    }
}
```

---

# ğŸ‰ å…¨éƒ¨åŠŸèƒ½å·²å®ç°

ä½ ç°åœ¨æ‹¥æœ‰ï¼š

- å®Œæ•´çš„æ¶ˆæ¯å­˜å‚¨ç³»ç»Ÿï¼ˆå‡åºï¼‰
- å®Œæ•´çš„æ–°æ¶ˆæ¯è¿‡æ»¤é€»è¾‘
- å®Œæ•´çš„æ–°æ¶ˆæ¯é€šçŸ¥ï¼ˆå•æ¡ã€å¤šæ¡ã€40+ï¼‰
- å®Œæ•´çš„é”™è¯¯é€šçŸ¥
- å®Œæ•´çš„è‹±æ–‡é€šçŸ¥æ–‡æ¡ˆ
- å®Œæ•´çš„è½®è¯¢æ•°æ®å¤„ç†
- å®Œæ•´çš„ JSON è§£æ
- å®Œæ•´çš„ Store å†™å…¥
- å®Œæ•´çš„ UI å®æ—¶åˆ·æ–°ï¼ˆå¹¿æ’­ï¼‰

---

# ä¸‹ä¸€æ­¥ï¼ˆä½ ä¹‹åä¼šåšçš„ï¼‰

ä½ æåˆ°æœªæ¥ä¼šåŠ å…¥ï¼š

- SSE å®æ—¶æ¶ˆæ¯
- PB Realtimeï¼ˆæ¯åˆ†é’Ÿ POSTï¼‰
- äº”åˆ†é’Ÿæ™®é€šè½®è¯¢ï¼ˆé˜²æ¼æ¶ˆæ¯ï¼‰

æˆ‘å·²ç»ä¸ºä½ ä¿ç•™äº†æ‰©å±•ç‚¹ï¼š

- `MessageStore` å¯ç›´æ¥å¤ç”¨
- `NotificationHelper.sendNewMessages()` å¯ç›´æ¥å¤ç”¨
- `PollingService.performRequest()` å¯æŠ½è±¡ä¸º `MessageProcessor`

ä½ éšæ—¶å¯ä»¥ç»§ç»­æ‰©å±•ã€‚

---

å¦‚æœä½ æ„¿æ„ï¼Œæˆ‘å¯ä»¥ç»§ç»­å¸®ä½ ï¼š

### âœ” æŠ½è±¡ MessageProcessor

### âœ” æŠ½è±¡ NotificationBuilder

### âœ” åŠ å…¥ SSE æ”¯æŒ

### âœ” åŠ å…¥ PB Realtime æ”¯æŒ

### âœ” åŠ å…¥æ¶ˆæ¯ç±»å‹ï¼ˆæ–‡æœ¬ã€å›¾ç‰‡ã€å›å¤ï¼‰

### âœ” åŠ å…¥ç‚¹å‡»é€šçŸ¥è·³è½¬åˆ°æ¶ˆæ¯é¡µé¢ï¼ˆDeep Linkï¼‰

ä½ æƒ³ç»§ç»­æ¨è¿›å“ªä¸€å—ï¼Ÿ


